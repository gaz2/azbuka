import { readFileSync, writeFileSync } from 'fs';
import { defineNuxtModule } from '@nuxt/kit';
import viteCompression from 'vite-plugin-compression';
import { globbySync } from 'globby';
import { resolve, dirname } from 'pathe';

const PREFIX = "\0virtual:";
function virtual(modules, cache = {}) {
  const _modules = /* @__PURE__ */ new Map();
  for (const [id, mod] of Object.entries(modules)) {
    cache[id] = mod;
    _modules.set(id, mod);
    _modules.set(resolve(id), mod);
  }
  return {
    name: "virtual",
    resolveId(id, importer) {
      if (id in modules) {
        return PREFIX + id;
      }
      if (importer) {
        const importerNoPrefix = importer.startsWith(PREFIX) ? importer.slice(PREFIX.length) : importer;
        const resolved = resolve(dirname(importerNoPrefix), id);
        if (_modules.has(resolved)) {
          return PREFIX + resolved;
        }
      }
      return null;
    },
    async load(id) {
      if (!id.startsWith(PREFIX)) {
        return null;
      }
      const idNoPrefix = id.slice(PREFIX.length);
      if (!_modules.has(idNoPrefix)) {
        return null;
      }
      let m = _modules.get(idNoPrefix);
      if (typeof m === "function") {
        m = await m();
      }
      if (m) {
        cache[id.replace(PREFIX, "")] = m;
      }
      return {
        code: m,
        map: null
      };
    }
  };
}

function getExtensionAndEncoding(options) {
  let fileExtension = "";
  let contentEncoding = "";
  switch (options.algorithm) {
    case "gzip":
      fileExtension = "gz";
      contentEncoding = "gzip";
      break;
    case "brotliCompress":
      fileExtension = "br";
      contentEncoding = "br";
      break;
  }
  return {
    fileExtension,
    contentEncoding
  };
}
function getCacheHeaders(options) {
  let cacheControlHeader = "";
  if (options.cacheControl) {
    const cacheControl = typeof options.cacheControl === "function" ? "cacheControl(assetPath)" : "cacheControl";
    cacheControlHeader = `res.setHeader("Cache-Control", ${cacheControl});`;
  } else {
    const maxAge = typeof options.maxAge === "function" ? "maxAge(assetPath)" : "maxAge";
    cacheControlHeader = `res.setHeader("Cache-Control", \`max-age=\${${maxAge}}, immutable\`);`;
  }
  return cacheControlHeader;
}
function getPublicAssetsConstants(options) {
  let cacheControl = "undefined";
  if (typeof options.cacheControl === "function") {
    cacheControl = options.cacheControl.toString();
  } else if (typeof options.cacheControl === "string") {
    cacheControl = `'${options.cacheControl}'`;
  }
  return `
const maxAge = ${options.maxAge};
const cacheControl = ${cacheControl};
const filter = ${options.viteCompression.filter};
`.trim();
}
function getFilterCondition(options) {
  return typeof options.viteCompression.filter === "function" ? "filter(assetPath)" : "filter.test(assetPath)";
}
function getPublicAssets(options) {
  const { fileExtension, contentEncoding } = getExtensionAndEncoding(options.viteCompression);
  const cacheControlHeader = getCacheHeaders(options);
  return `
import { promises as fsp, constants } from 'fs'
import { resolve } from 'pathe'
import { dirname } from 'pathe'
import { fileURLToPath } from 'url'
import assets from '#internal/nitro/virtual/public-assets-data'

${getPublicAssetsConstants(options)}
  
export async function readAsset (id, res) {
  const serverDir = dirname(fileURLToPath(import.meta.url))
  let assetPath = resolve(serverDir, assets[id].path)

  if (${getFilterCondition(options)}) {
    try {
      await fsp.access(\`\${assetPath}.${fileExtension}\`, constants.R_OK | constants.W_OK);
      assetPath = \`\${assetPath}.${fileExtension}\`;
      res.setHeader('Content-Encoding', '${contentEncoding}');
    } catch {}
  }

  ${cacheControlHeader}

  return fsp.readFile(assetPath);
}`;
}

const module = defineNuxtModule({
  meta: {
    name: "compression",
    configKey: "compression"
  },
  defaults: {
    maxAge: 60 * 60 * 24 * 365,
    viteCompression: {
      algorithm: "brotliCompress",
      filter: /\.(js|mjs|json|css|html)$/i
    }
  },
  setup(options, nuxt) {
    nuxt.hook("vite:extend", (context) => {
      context.config.plugins?.push(viteCompression(options.viteCompression));
    });
    nuxt.hook("nitro:build:before", (nitro) => {
      nitro.options.rollupConfig?.plugins?.push(virtual({
        "#internal/nitro/virtual/public-assets-node": getPublicAssets(options)
      }, nitro.vfs));
      nitro.hooks.hook("compiled", (nitro2) => {
        const [nodeServer] = globbySync("**/node-server.mjs", {
          cwd: nitro2.options.output.dir,
          absolute: true
        });
        if (nodeServer) {
          let nodeServerContent = readFileSync(nodeServer, "utf8");
          nodeServerContent = nodeServerContent.replace(/readAsset\(id\)/g, "readAsset(id, event.res)");
          writeFileSync(nodeServer, nodeServerContent);
        }
      });
    });
    nuxt.hook("build:done", () => {
    });
  }
});

export { module as default };
